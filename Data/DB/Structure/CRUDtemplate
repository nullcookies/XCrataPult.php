<?php

namespace {%NAMESPACE%}\abstracts;

use \X\Data\DB\Collection;
use \X\Data\DB\CollectionMember;
use \X\Data\DB\CRUD;
use \X\Data\DB\DB;
use \X\Data\Persistent\Cache;
use \X\Tools\Strings;
use \X\C;

/**
 * @class {%CLASSNAME%}Collection_helper
 *
 * Helper class for IDE correct autocompletion.
 * It will never be used to not to slow down functions calls.
 *
 * @method {%CLASSNAME%}Collection_helper group
 * @method {%CLASSNAME%}Collection_helper fields
 * @method {%CLASSNAME%}Collection_helper order
 * @method {%CLASSNAME%}Collection_helper resetScope
 * @method {%CLASSNAME%}Collection_helper excludeFields
 * @method {%CLASSNAME%}Collection_helper limit
 * @method {%CLASSNAME%}Collection_helper resetConditions
 * @method {%CLASSNAME%}Collection_helper by
 * @method {%CLASSNAME%}Collection_helper addFieldsToSelect
 * @method {%CLASSNAME%}Collection_helper addTable
 *
 * @method \{%NAMESPACE%}\{%CLASSNAME%} row
 * @method \{%NAMESPACE%}\{%CLASSNAME%} next
 * @method \{%NAMESPACE%}\{%CLASSNAME%} current
 * @method \{%NAMESPACE%}\{%CLASSNAME%} prev
 * @method \{%NAMESPACE%}\{%CLASSNAME%} first
 * @method \{%NAMESPACE%}\{%CLASSNAME%} last
 * @method \{%NAMESPACE%}\{%CLASSNAME%} offsetGet($offset)
 */
class {%CLASSNAME%}Collection_helper extends Collection{
}

/**
 * Class {%CLASSNAME%} represents table {%DATABASE_ALIAS%}/{%TABLENAME%}.
 *
 * @class {%CLASSNAME%}
 * @author automatically generated by XCratapult.php \X\Data\DB\DB
 * @version {%VERSION%}
 *
 * !          DO NOT MODIFY THIS FILE         !
 * ! IT WILL BE REWRITTEN AFTER SCHEMA UPDATE !
 * !              AUTOMATICALLY               !
 *
 * If you need to add functionality or rewrite methods,
 * Use class {%NAMESPACE%}\{%CLASSNAME%}'
 */
abstract class {%CLASSNAME%} extends CRUD{

  const TABLE_NAME = '{%TABLENAME%}';
  protected $className;
  protected $listeners=[];
  protected $_fromCache_=false;
  protected $rangeTriggers=[];

  const BAD_CALLBACK = 2002;

{%FIELDNAMES%}

{%REFS%}

{%FIELDS%}
{%FIELDSCNAMES%}
{%PRIMARYFIELDS%}
{%PROPERTIES%}

{%CACHEKEY%}
{%ISVALID%}
{%INVALIDATE%}

  public static function getRangeTriggerFromParamValues($params){
    $range=[];
    ksort($params);
    foreach($params as $key=>$val){
      $range[]='['.$key.']:'.strval($val);
    }
    $range = implode("--", $range);
    return self::TABLE_NAME.':'.$range;
  }
  public function getRangeTriggerFromParams($params){
    $range=[];
    if (\X\Validators\Values::isAssoc($params)){
      ksort($params);
      foreach($params as $key=>$val){
        $range[]='['.$key.']:'.strval($val);
      }
    }else{
      sort($params);
      foreach($params as $field){
        $range[]='['.$field.']:'.strval($this->fieldValue($field));
      }
    }
    $range = implode("--", $range);
    return self::TABLE_NAME.':'.$range;
  }

  public function addRangeTrigger($params){
    $range = '';
    if (is_array($params)){
      $range = $this->getRangeTriggerFromParams($params);
    }else{
      $range = self::TABLE_NAME.':'.strval($params);
    }
    $this->rangeTriggers[]=$range;
    $this->rangeTriggers = array_unique($this->rangeTriggers);
  }

  public function getRangeTriggers(){
    return $this->rangeTriggers;
  }
  public function fireRangeTriggers(){
    foreach($this->getRangeTriggers() as $range){
      Cache::getInstance()->fireModifyTrigger($range);
    }
  }

  public function isFromCache(){
    return !!$this->_fromCache_;
  }

  public function setFromCache(){
    return $this->_fromCache_=true;
  }

  public function invalidateCache(){
    if (Cache::getInstance()->enabled()){
      $this->fireRangeTriggers();
    }
    if (!$this->cacheKey()){
      return false;
    }
    if (Cache::getInstance()->enabled() && $this->isValid()){
      Cache::getInstance()->groupRemoveItem('DB_{%DATABASE_ALIAS%}_{%TABLENAME%}', $this->cacheKey());
      Cache::getInstance()->fireModifyTrigger(self::tableChangeTriggerKey());
      return true;
    }
  }

  protected function cache($noTrigger=false){
    if (!$this->cacheKey() || !C::getDbCacheTtl()){
      return false;
    }
    if (Cache::getInstance()->enabled() && $this->isValid()){
      return Cache::getInstance()->groupSetItem('DB_{%DATABASE_ALIAS%}_{%TABLENAME%}', $this->cacheKey(), $this, C::getDbCacheTtl(),$noTrigger);
    }
  }

  public static function &connection(){
    static::mutate();
    return DB::connectionByAlias('{%DATABASE_ALIAS%}');
  }

{%GETTERS%}
{%SETTERS%}
{%AUTOINCREMENT%}

  protected function __construct(){
    $this->className = get_called_class();
    $this->hook_constructor_after();
  }

{%SELECTORS%}

  /**
     * @param bool $asArray if you want to invoke [asArray] method on every fetched object. False by default
     * @return {%CLASSNAME%}Collection_helper
     */
  public static function getAll(){
    return static::get();
  }

{%PRETENDREAL%}
{%CREATEFROMRAW%}
{%ASARRAY%}


  /**
   * @param $conditions
   * @return {%CLASSNAME%}Collection_helper
   */
  public static function get($conditions=''){
    $vars=null;
    if (func_num_args()>1){
      if (func_num_args()==2 && is_array(func_get_arg(1))){
        $vars = func_get_arg(1);
      }else{
        $vars = array_slice(func_get_args(),1);
      }
    }
    if ($vars!==null){
      return (new Collection(static::connection(), '{%TABLENAME%}'.($conditions ? ', '.$conditions : ''), $vars))->scope("{%TABLENAME%}");
    }else{
      return (new Collection(static::connection(), '{%TABLENAME%}'.($conditions ? ', '.$conditions : '')))->scope("{%TABLENAME%}");
    }
  }

  private static function getByOneField($varCondition, $val, $limit=0, $groupBy=null){
    return static::get($varCondition.($limit ? ', #'.$limit : '').($groupBy ? ',('.$groupBy.')': ''), is_array($val) ? $val : ["val"=>$val]);
  }

  public static function getFields(){
    static::mutate();
    return static::$Fields;
  }

  public static function getCFields(){
    static::mutate();
    return static::$FieldsCnames;
  }

  public static function getPrimaryFields(){
    static::mutate();
    return static::$PrimaryFields;
  }

  public function getPrimaryField($fieldName){
    if (array_key_exists($fieldName, static::$PrimaryFields)){
      return $this->{'PRIMARY_'.static::$PrimaryFields[$fieldName]};
    }else{
      throw new \Exception("Primary field '".$fieldName."' doesn't exist in table ".static::TABLE_NAME."!", self::ERR_WRONG_PRIMARY_FIELD);
    }
  }

  public function save(){
  	try{
  	  $this->hook_save_before();
  		static::connection()->store($this);
  		$this->hook_save_after();
  	}catch(\Exception $e){
  		throw new \Exception('Could not save to table '.static::TABLE_NAME.'!', $e->getCode(), $e);
  	}
    $this->pretendReal();
    $this->invalidateCache();
    return $this;
  }

  public function delete(){
  	try{
  		static::connection()->delete($this);
  	}catch(\Exception $e){
  		throw new \Exception('Could not delete from table '.static::TABLE_NAME.'!', $e->getCode(), $e);
  	}
    $this->invalidateCache();
    $this->invalidatePK();
  }

  public static function getField($field){
    static::mutate();
    return array_key_exists($field, static::$Fields) ? static::$Fields[$field] : null;
  }

  public function getFieldData($fieldName){
    static::mutate();
    if ($field = (array_key_exists($fieldName, static::$Fields) ? static::$Fields[$fieldName] : null)){
      return call_user_func([$this, $field['getter']]);
    }
    return ;
  }

  public static function hook_constructor_before(&$className){}
  public function hook_constructor_after(){}

  public function hook_createFromRaw_before(&$rawFields){}
  public function hook_createFromRaw_after(){}

  public function hook_asArray_before(){}
  public function hook_asArray_after(&$answer){}

  public function hook_save_before(){}
  public function hook_save_after(){}

  public function hook_realObjectUpdate(){}

}