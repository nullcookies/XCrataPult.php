<?php

namespace {%NAMESPACE%}\abstracts;

use \X\Data\DB\Collection;
use \X\Data\DB\CRUD;
use \X\Data\DB\DB;
use \X\Data\Persistent\Cache;
use \X\Debug\Logger;
use \X\C;

/**
 * Class {%CLASSNAME%} represents table {%DATABASE_ALIAS%}/{%TABLENAME%}.
 *
 * @author automatically generated by XCratapult.php \X\Data\DB\DB
 * @version {%VERSION%}
 *
 * !          DO NOT MODIFY THIS FILE         !
 * ! IT WILL BE REWRITTEN AFTER SCHEMA UPDATE !
 * !              AUTOMATICALLY               !
 *
 * If you need to add functionality or rewrite methods,
 * Use class {%NAMESPACE%}\{%CLASSNAME%}'
 */
abstract class {%CLASSNAME%} extends CRUD{

  const TABLE_NAME = '{%TABLENAME%}';
  protected $className;
  protected $listeners=[];

  const BAD_CALLBACK = 2002;

{%FIELDNAMES%}

{%REFS%}

{%FIELDS%}
{%PRIMARYFIELDS%}
{%PROPERTIES%}

{%CACHEKEY%}
{%ISVALID%}
{%INVALIDATE%}

  public function invalidateCache(){
    if (!$this->cacheKey()){
      return false;
    }
    if (Cache::getInstance()->enabled() && $this->isValid()){
      return Cache::getInstance()->groupRemoveItem('DB_{%DATABASE_ALIAS%}_{%TABLENAME%}', $this->cacheKey());
    }
  }

  protected function cache(){
    if (!$this->cacheKey() || !C::getDbCacheTtl()){
      return false;
    }
    if (Cache::getInstance()->enabled() && $this->isValid()){
      return Cache::getInstance()->groupSetItem('DB_{%DATABASE_ALIAS%}_{%TABLENAME%}', $this->cacheKey(), $this, C::getDbCacheTtl());
    }
  }

  public static function &connection(){
    static::mutate();
    return DB::connectionByAlias('{%DATABASE_ALIAS%}');
  }

{%GETTERS%}
{%SETTERS%}
{%AUTOINCREMENT%}

  protected function __construct(){
    $this->className = get_called_class();
    $this->hook_constructor_after();
  }

{%SELECTORS%}

  /**
     * @param bool $asArray if you want to invoke [asArray] method on every fetched object. False by default
     * @return Collection|{%CLASSNAME%}[]
     */
  public static function getAll($asArray=false){
    return static::get(null, null, 0, $asArray);
  }

{%PRETENDREAL%}
{%CREATEFROMRAW%}
{%ASARRAY%}

  public static function get($where=null, $fields=null, $limit=0, $asArray=false, $order=Array()){
    return static::connection()->getSimple([
      'conditions'=>[$where, $fields],
      'asArray'=>$asArray,
      'limit'=>$limit,
      'instantiator'=>get_called_class().'::createFromRaw',
      'order'=>$order
    ]);
  }

  public static function getFields(){
    static::mutate();
    return static::$Fields;
  }

  public static function getPrimaryFields(){
    static::mutate();
    return static::$PrimaryFields;
  }

  public function getPrimaryField($fieldName){
    if (array_key_exists($fieldName, static::$PrimaryFields)){
      return $this->{'PRIMARY_'.static::$PrimaryFields[$fieldName]};
    }else{
      throw new \Exception("Primary field '".$fieldName."' doesn't exist in table ".static::TABLE_NAME."!", self::ERR_WRONG_PRIMARY_FIELD);
    }
  }

  public function save(){
  	try{
  		static::connection()->store($this);
  	}catch(\Exception $e){
  		throw new \Exception('Could not save to table '.static::TABLE_NAME.'!', $e->getCode(), $e);
  	}
  	if ($this->isValid()){
  		$this->invalidateCache();
  	}
    $this->pretendReal();
    return $this;
  }

  public function delete(){
  	try{
  		static::connection()->delete($this);
  	}catch(\Exception $e){
  		throw new \Exception('Could not delete from table '.static::TABLE_NAME.'!', $e->getCode(), $e);
  	}
  	if ($this->isValid()){
  		$this->invalidateCache();
  	}
    $this->invalidate();
  }

  public static function getField($field){
    static::mutate();
    return array_key_exists($field, static::$Fields) ? static::$Fields[$field] : null;
  }

  public function getFieldData($fieldName){
    static::mutate();
    if ($field = (array_key_exists($fieldName, static::$Fields) ? static::$Fields[$fieldName] : null)){
      return call_user_func([$this, $field['getter']]);
    }
    return ;
  }

  public static function hook_constructor_before(&$className){}
  public function hook_constructor_after(){}

  public function hook_createFromRaw_before(&$rawFields){}
  public function hook_createFromRaw_after(){}

  public function hook_asArray_before(){}
  public function hook_asArray_after(&$answer){}

}