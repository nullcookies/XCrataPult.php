<?php

namespace {%NAMESPACE%}\abstracts;

use \X\Data\DB\Collection;
use \X\Data\DB\CRUD;
use \X\Data\DB\DB;
use \X\Data\Persistent\Cache;
use \X\Tools\Strings;
use \X\C;

/**
 * Class {%CLASSNAME%} represents table {%DATABASE_ALIAS%}/{%TABLENAME%}.
 *
 * @author automatically generated by XCratapult.php \X\Data\DB\DB
 * @version {%VERSION%}
 *
 * !          DO NOT MODIFY THIS FILE         !
 * ! IT WILL BE REWRITTEN AFTER SCHEMA UPDATE !
 * !              AUTOMATICALLY               !
 *
 * If you need to add functionality or rewrite methods,
 * Use class {%NAMESPACE%}\{%CLASSNAME%}'
 */
abstract class {%CLASSNAME%} extends CRUD{

  const TABLE_NAME = '{%TABLENAME%}';
  protected $className;
  protected $listeners=[];
  protected $_fromCache_=false;

  const BAD_CALLBACK = 2002;

{%FIELDNAMES%}

{%REFS%}

{%FIELDS%}
{%FIELDSCNAMES%}
{%PRIMARYFIELDS%}
{%PROPERTIES%}

{%CACHEKEY%}
{%ISVALID%}
{%INVALIDATE%}

  public function isFromCache(){
    return !!$this->_fromCache_;
  }

  public function setFromCache(){
    return $this->_fromCache_=true;
  }

  public function invalidateCache(){
    if (!$this->cacheKey()){
      return false;
    }
    if (Cache::getInstance()->enabled() && $this->isValid()){
      Cache::getInstance()->groupRemoveItem('DB_{%DATABASE_ALIAS%}_{%TABLENAME%}', $this->cacheKey());
      return true;
    }
  }

  protected function cache($noTrigger=false){
    if (!$this->cacheKey() || !C::getDbCacheTtl()){
      return false;
    }
    if (Cache::getInstance()->enabled() && $this->isValid()){
      return Cache::getInstance()->groupSetItem('DB_{%DATABASE_ALIAS%}_{%TABLENAME%}', $this->cacheKey(), $this, C::getDbCacheTtl(),$noTrigger);
    }
  }

  public static function &connection(){
    static::mutate();
    return DB::connectionByAlias('{%DATABASE_ALIAS%}');
  }

{%GETTERS%}
{%SETTERS%}
{%AUTOINCREMENT%}

  protected function __construct(){
    $this->className = get_called_class();
    $this->hook_constructor_after();
  }

{%SELECTORS%}

  /**
     * @param bool $asArray if you want to invoke [asArray] method on every fetched object. False by default
     * @return Collection|{%CLASSNAME%}[]
     */
  public static function getAll(){
    return static::get();
  }

{%PRETENDREAL%}
{%CREATEFROMRAW%}
{%ASARRAY%}

  public static function get($conditions=''){
    $vars=null;
    if (func_num_args()>1){
      if (func_num_args()==2 && is_array(func_get_arg(1))){
        $vars = func_get_arg(1);
      }else{
        $vars = array_slice(func_get_args(),1);
      }
    }
    if ($vars!==null){
      return (new Collection(static::connection(), '{%TABLENAME%}'.($conditions ? ', '.$conditions : ''), $vars))->scope("{%TABLENAME%}");
    }else{
      return (new Collection(static::connection(), '{%TABLENAME%}'.($conditions ? ', '.$conditions : '')))->scope("{%TABLENAME%}");
    }
  }

  private static function getByOneField($varCondition, $val, $limit=0, $groupBy=null){
    return static::get($varCondition.($limit ? ', #'.$limit : '').($groupBy ? ',('.$groupBy.')': ''), is_array($val) ? $val : ["val"=>$val]);
  }

  public static function getFields(){
    static::mutate();
    return static::$Fields;
  }

  public static function getCFields(){
    static::mutate();
    return static::$FieldsCnames;
  }

  public static function getPrimaryFields(){
    static::mutate();
    return static::$PrimaryFields;
  }

  public function getPrimaryField($fieldName){
    if (array_key_exists($fieldName, static::$PrimaryFields)){
      return $this->{'PRIMARY_'.static::$PrimaryFields[$fieldName]};
    }else{
      throw new \Exception("Primary field '".$fieldName."' doesn't exist in table ".static::TABLE_NAME."!", self::ERR_WRONG_PRIMARY_FIELD);
    }
  }

  public function save(){
  	try{
  	  $this->hook_save_before();
  		static::connection()->store($this);
  		$this->hook_save_after();
  	}catch(\Exception $e){
  		throw new \Exception('Could not save to table '.static::TABLE_NAME.'!', $e->getCode(), $e);
  	}
  	if ($this->isValid()){
  		$this->invalidateCache();
  	}
    if (Cache::getInstance()->enabled()){
      Cache::getInstance()->fireModifyTrigger(self::tableChangeTriggerKey());
    }
    $this->pretendReal();
    return $this;
  }

  public function delete(){
  	try{
  		static::connection()->delete($this);
  	}catch(\Exception $e){
  		throw new \Exception('Could not delete from table '.static::TABLE_NAME.'!', $e->getCode(), $e);
  	}
  	if ($this->isValid()){
  		$this->invalidateCache();
  	}
    if (Cache::getInstance()->enabled()){
      Cache::getInstance()->fireModifyTrigger(self::tableChangeTriggerKey());
    }
    $this->invalidate();
  }

  public static function getField($field){
    static::mutate();
    return array_key_exists($field, static::$Fields) ? static::$Fields[$field] : null;
  }

  public function getFieldData($fieldName){
    static::mutate();
    if ($field = (array_key_exists($fieldName, static::$Fields) ? static::$Fields[$fieldName] : null)){
      return call_user_func([$this, $field['getter']]);
    }
    return ;
  }

  public static function hook_constructor_before(&$className){}
  public function hook_constructor_after(){}

  public function hook_createFromRaw_before(&$rawFields){}
  public function hook_createFromRaw_after(){}

  public function hook_asArray_before(){}
  public function hook_asArray_after(&$answer){}

  public function hook_save_before(){}
  public function hook_save_after(){}

}